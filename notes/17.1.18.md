# Graph algorithms

## introduction 

A graph is a set of vertices and edges 


**Path** = a sequence of edges connecting distinct vertices 


**Cycle** = path where start and end vertices are the same 


## Graphs in Biology 


examples - biological pathways, photogenic tree, neural net, hidden Markov model  


## Computing with Graphs 

### Breadth-first search 

```
Breadth_First_Search(G, start): 
	for vertex in G: 
		vertex.visited = false 

	Q = new empty queue 
	Q.enqueue(start)

	while Q is not empty: 

		v=Q.dequeue() 

		for n adjacent to v: 
			if !n.visted: 
				n.visited = true 
				Q.enqueue(n) 
```


### Depth first search, implemented with recursion 

```
Depth_First_Search(G, start): 
	v.visited = true 

	for adjacent to v: 
		if !n.visited: 
			Depth_First_Search(G, n)
``` 


### Shorted path- Dijkstra's Algorithm 

```
Shortest_Path(G, start):	
	Q = []

	for vertex v in G:
		v.dist= Infinity
		v.prev= NULL
		Q.append(v)

	start.dist= 0

	while Q is not empty:
		v = v in Q where v.dist is smallest
		Q.remove(v)

		for each neighbor u of v:
			x = v.dist+ edge_len(v, u)
			if x < u.dist:
				u.dist = x
				u.prev = v
```

## Path traversal 

### Hamiltonian paths
Hamiltonian path visits each vertex exactly once. Finding a Hamiltonian path in an arbitrary graph is NP-complete, and finding a Hamiltonian path of minimum cost is the Traveling Salesman Problem 


### Eulerian paths 
Visits each edge exactly once. Eulerian cycles require that all nodes in a graph have an even degree. Can be done in linear time. 


## Flow 


Problem - How do we get the maximum flow from one node to another? 


Edge weights indicate a flow "capacity"


### Finding max flow - Ford-Fulkerson Algorithm 


Flow - value put on the edge 

```
Max_Flow(G, source, sink):
	
	flow = 0F = [[0 for j in range(n)] 
	
	for i in range(n)]

		while TRUE:
			c, path = Find_Path(G, source, sink, F)
			if c= 0:
				break
			flow = flow + c
			
			v = sink

			while v != source:
				u= path[v]
				F[u,v] += c
				F[v,u] -= c
				v = u

	return flow, F
```



## Minimum spanning trees 


A **spanning tree** is a subgraph of G such that includes every vertex of G ans is a tree 

A **tree** is a graph such that there is only one edge between any two vertices 

**Minimum spanning tree**- a spanning tree with the lowest sum of edge weights

**Cut** = partition of the graph. Respects a set of edges if no edges from the set cross the cut. 

**A light edge**  is an edge of minimum weight that does not cross the cut. A light edge is safe to add to our minimum spanning tree, as it doesn't create a cycle, and has minimum weight. 


### Prim's algorithm  

```
First, choose a vertex to be the root of the tree 

While the tree does not contain all of the vertices of the graph: 
	Find the lowest cost of leaving the tree 
	Add edge to tree 
```

## Subgraph isomorphism 


Two graphs are **isomorphic** if a 1-to-1 correspondence between their vertex sets exists that preserve adjacencies

### Ullman Algorithm - determining isomorphism 

```
search(graph, subgraph, assignments): 

if every edge between assigned vertices in the subgraph is not also an edge in the raph: 
	return False 

if all subgraph vertices have been assigned: 
	return True 

else: 
	for all possible assinments for the next vertex of the subgraph: 
		if search(graph, subgraph, possible_assignment): 
			return True 
```










