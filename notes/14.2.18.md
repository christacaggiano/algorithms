# Dynamic Programming

Divide and conquer technique - formulate solution as a recurrence relation

Hallmarks of a dynamic programming problem

* optimal substructure
  - an optimal solution can be built from optimal sub-solutions
* overlapping subproblems
  - the same subproblems keep showing up

2 approaches:
* bottom-up method
  - there must be an evaluation order that solves smaller problems before larger ones
  - by storing and recalling the solutions to smaller problems, the large ones can be efficiently computed
* top-down with memoization
  - follow the usual recursive procedure, but store your result along the way
* both methods have asymptotic running time
* dynamic programming is always a time-memory trade-off

Bottom up works by reverse topological sort

Top down is a depth first search


## Dynamic Programming in 4 Steps

1. Characterize structure of an optimal solution
2. Recursively define solution's value
3. Compute the value
4. Construct the solution

## Pairwise sequence alignment

An **alignment** is a a mapping from one sequence to another, identifying elements that are likely to have arisen from a common ancestry  

**Homology** is an evolutionary relationship that either exists or does not. Cannot be partial

**Ortholog** homolog with shared function

**Paralog** homolog that arose through a gene duplication event. Often have divergent function

**Similarity** a measure of the quality of alignment between two sequences. High similarity is evidence for homology. Similar sequences may be orthologs or paralogs


**Similarity** can be defined by counting positions that are identical between two sequences. Gaps can be important

Gaps/mismatches-
* some amino acids are more substitutable for each other than other
* can introduce mismatch costs for handling different substitutions
  - do not usually use mismatch costs in algining nucleotides because one substitution is not better than others in terms of coding potential 
